import { Action } from 'redux';
export declare type PendingAction<T extends string, P> = Action<T> & Promise<P> & {
    status: 'pending';
};
export declare type ResolvedAction<T extends string, P> = Action<T> & {
    payload: P;
    status: 'resolved';
};
export declare type RejectedAction<T extends string> = Action<T> & {
    payload: Error;
    status: 'rejected';
};
export declare function isRejectedAction(value: unknown): value is RejectedAction<string>;
export declare type AsyncAction<T extends string, P> = PendingAction<T, P> | ResolvedAction<T, P> | RejectedAction<T>;
export declare type GetAsyncAction<A> = A extends PendingAction<infer T, infer P> ? AsyncAction<T, P> : A extends ResolvedAction<infer T, infer P> ? AsyncAction<T, P> : never;
export declare type GetAllActions<T> = {
    [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : never;
}[keyof T];
export declare type GetAllAsyncActions<T> = GetAsyncAction<GetAllActions<T>>;
export declare function isPendingAction(value: unknown): value is PendingAction<string, unknown>;
export declare function makeAction<A extends unknown[], T extends string, P>(type: T, impl: (...args: A) => Promise<P>): (...args: A) => PendingAction<T, P>;
//# sourceMappingURL=action.d.ts.map