"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
var action_1 = require("./action");
var middleware_1 = require("./middleware");
var reducer_1 = require("./reducer");
var redux_1 = require("redux");
describe('middleware', function () {
    var defaultState = {
        status: 'resolved',
        sum: 0
    };
    var actions = {
        add: action_1.makeAction('add', function (a, b) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, { a: a, b: b }];
            });
        }); }),
        subtract: action_1.makeAction('subtract', function (a, b) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, { a: a, b: b }];
            });
        }); }),
        reject: action_1.makeAction('reject', function (a, b) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error('Test reject');
            });
        }); })
    };
    function result(state, action) {
        if (state === void 0) { state = defaultState; }
        switch (action.type) {
            case 'add':
                return reducer_1.reduce(state, action, function (state, pending) { return ({
                    status: pending.status,
                    sum: state.sum
                }); }, function (state, resolved) { return ({
                    status: resolved.status,
                    sum: resolved.payload.a + resolved.payload.b
                }); }, function (state, rejected) { return ({ status: rejected.status, sum: 0 }); });
            case 'subtract':
                return reducer_1.reduce(state, action, function (state, pending) { return ({
                    status: pending.status,
                    sum: state.sum
                }); }, function (state, resolved) { return ({
                    status: resolved.status,
                    sum: resolved.payload.a - resolved.payload.b
                }); }, function (state, rejected) { return ({ status: rejected.status, sum: 0 }); });
            case 'reject':
                return reducer_1.reduce(state, action, function (state, pending) { return ({
                    status: pending.status,
                    sum: state.sum
                }); }, function (state, resolved) { return ({
                    status: resolved.status,
                    sum: 0
                }); }, function (state, rejected) { return ({ status: rejected.status, sum: 0 }); });
            default:
                return state;
        }
    }
    function getStore() {
        return redux_1.createStore(redux_1.combineReducers({ result: result }), redux_1.applyMiddleware(middleware_1.middleware));
    }
    describe('pending and resolved', function () {
        it('makes it easy to dispatch async actions for redux', function () { return __awaiter(void 0, void 0, void 0, function () {
            var store;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        store = getStore();
                        return [4 /*yield*/, store.dispatch(actions.add(1, 2))];
                    case 1:
                        _a.sent();
                        expect(store.getState()).toEqual({
                            result: {
                                status: 'resolved',
                                sum: 3
                            }
                        });
                        return [4 /*yield*/, store.dispatch(actions.subtract(1, 2))];
                    case 2:
                        _a.sent();
                        expect(store.getState()).toEqual({
                            result: {
                                status: 'resolved',
                                sum: -1
                            }
                        });
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('rejected', function () {
        it('handles rejected actions', function () { return __awaiter(void 0, void 0, void 0, function () {
            var store, error, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        store = getStore();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, store.dispatch(actions.reject(1, 2))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        error = err_1;
                        return [3 /*break*/, 4];
                    case 4:
                        expect(error).toBeTruthy();
                        expect(error.message).toBe('Test reject');
                        expect(store.getState()).toEqual({
                            result: {
                                status: 'rejected',
                                sum: 0
                            }
                        });
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWlkZGxld2FyZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NsaWVudC9hc3luYy9taWRkbGV3YXJlLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBeUQ7QUFDekQsMkNBQXlDO0FBQ3pDLHFDQUFrQztBQUNsQywrQkFBcUU7QUFFckUsUUFBUSxDQUFDLFlBQVksRUFBRTtJQU9yQixJQUFNLFlBQVksR0FBVTtRQUMxQixNQUFNLEVBQUUsVUFBVTtRQUNsQixHQUFHLEVBQUUsQ0FBQztLQUNQLENBQUE7SUFFRCxJQUFNLE9BQU8sR0FBRztRQUNkLEdBQUcsRUFBRSxtQkFBVSxDQUFDLEtBQUssRUFBRSxVQUFPLENBQVMsRUFBRSxDQUFTOztnQkFDaEQsc0JBQU8sRUFBQyxDQUFDLEdBQUEsRUFBRSxDQUFDLEdBQUEsRUFBQyxFQUFBOzthQUNkLENBQUM7UUFDRixRQUFRLEVBQUUsbUJBQVUsQ0FBQyxVQUFVLEVBQUUsVUFBTyxDQUFTLEVBQUUsQ0FBUzs7Z0JBQzFELHNCQUFPLEVBQUMsQ0FBQyxHQUFBLEVBQUUsQ0FBQyxHQUFBLEVBQUMsRUFBQTs7YUFDZCxDQUFDO1FBQ0YsTUFBTSxFQUFFLG1CQUFVLENBQUMsUUFBUSxFQUFFLFVBQU8sQ0FBUyxFQUFFLENBQVM7O2dCQUN0RCxNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFBOzthQUMvQixDQUFDO0tBQ0gsQ0FBQTtJQUlELFNBQVMsTUFBTSxDQUFDLEtBQW9CLEVBQUUsTUFBYztRQUFwQyxzQkFBQSxFQUFBLG9CQUFvQjtRQUNsQyxRQUFRLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDbkIsS0FBSyxLQUFLO2dCQUNSLE9BQU8sZ0JBQU0sQ0FDWCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFVBQUMsS0FBSyxFQUFFLE9BQU8sSUFBSyxPQUFBLENBQUM7b0JBQ25C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QVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQTs7d0JBQTVDLFNBQTRDLENBQUE7d0JBQzVDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUM7NEJBQy9CLE1BQU0sRUFBRTtnQ0FDTixNQUFNLEVBQUUsVUFBVTtnQ0FDbEIsR0FBRyxFQUFFLENBQUMsQ0FBQzs2QkFDUjt5QkFDRixDQUFDLENBQUE7Ozs7YUFDSCxDQUFDLENBQUE7SUFDSixDQUFDLENBQUMsQ0FBQTtJQUVGLFFBQVEsQ0FBQyxVQUFVLEVBQUU7UUFDbkIsRUFBRSxDQUFDLDBCQUEwQixFQUFFOzs7Ozt3QkFDdkIsS0FBSyxHQUFHLFFBQVEsRUFBRSxDQUFBOzs7O3dCQUd0QixxQkFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUE7O3dCQUExQyxTQUEwQyxDQUFBOzs7O3dCQUUxQyxLQUFLLEdBQUcsS0FBRyxDQUFBOzs7d0JBRWIsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFBO3dCQUMxQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQTt3QkFDekMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQzs0QkFDL0IsTUFBTSxFQUFFO2dDQUNOLE1BQU0sRUFBRSxVQUFVO2dDQUNsQixHQUFHLEVBQUUsQ0FBQzs2QkFDUDt5QkFDRixDQUFDLENBQUE7Ozs7YUFDSCxDQUFDLENBQUE7SUFDSixDQUFDLENBQUMsQ0FBQTtBQUVKLENBQUMsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2V0QWxsQXN5bmNBY3Rpb25zLCBtYWtlQWN0aW9uIH0gZnJvbSAnLi9hY3Rpb24nXG5pbXBvcnQgeyBtaWRkbGV3YXJlIH0gZnJvbSAnLi9taWRkbGV3YXJlJ1xuaW1wb3J0IHsgcmVkdWNlIH0gZnJvbSAnLi9yZWR1Y2VyJ1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSwgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnXG5cbmRlc2NyaWJlKCdtaWRkbGV3YXJlJywgKCkgPT4ge1xuXG4gIGludGVyZmFjZSBTdGF0ZSB7XG4gICAgc3VtOiBudW1iZXJcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdyZXNvbHZlZCcgfCAncmVqZWN0ZWQnXG4gIH1cblxuICBjb25zdCBkZWZhdWx0U3RhdGU6IFN0YXRlID0ge1xuICAgIHN0YXR1czogJ3Jlc29sdmVkJyxcbiAgICBzdW06IDAsXG4gIH1cblxuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGFkZDogbWFrZUFjdGlvbignYWRkJywgYXN5bmMgKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB7XG4gICAgICByZXR1cm4ge2EsIGJ9XG4gICAgfSksXG4gICAgc3VidHJhY3Q6IG1ha2VBY3Rpb24oJ3N1YnRyYWN0JywgYXN5bmMgKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB7XG4gICAgICByZXR1cm4ge2EsIGJ9XG4gICAgfSksXG4gICAgcmVqZWN0OiBtYWtlQWN0aW9uKCdyZWplY3QnLCBhc3luYyAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVzdCByZWplY3QnKVxuICAgIH0pLFxuICB9XG5cbiAgdHlwZSBBY3Rpb24gPSBHZXRBbGxBc3luY0FjdGlvbnM8dHlwZW9mIGFjdGlvbnM+XG5cbiAgZnVuY3Rpb24gcmVzdWx0KHN0YXRlID0gZGVmYXVsdFN0YXRlLCBhY3Rpb246IEFjdGlvbik6IFN0YXRlIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdhZGQnOlxuICAgICAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAoc3RhdGUsIHBlbmRpbmcpID0+ICh7XG4gICAgICAgICAgICBzdGF0dXM6IHBlbmRpbmcuc3RhdHVzLFxuICAgICAgICAgICAgc3VtOiBzdGF0ZS5zdW0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKHN0YXRlLCByZXNvbHZlZCkgPT4gKHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzb2x2ZWQuc3RhdHVzLFxuICAgICAgICAgICAgc3VtOiByZXNvbHZlZC5wYXlsb2FkLmEgKyByZXNvbHZlZC5wYXlsb2FkLmIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKHN0YXRlLCByZWplY3RlZCkgPT4gKHtzdGF0dXM6IHJlamVjdGVkLnN0YXR1cywgc3VtOiAwfSksXG4gICAgICAgIClcbiAgICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgKHN0YXRlLCBwZW5kaW5nKSA9PiAoe1xuICAgICAgICAgICAgc3RhdHVzOiBwZW5kaW5nLnN0YXR1cyxcbiAgICAgICAgICAgIHN1bTogc3RhdGUuc3VtLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChzdGF0ZSwgcmVzb2x2ZWQpID0+ICh7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc29sdmVkLnN0YXR1cyxcbiAgICAgICAgICAgIHN1bTogcmVzb2x2ZWQucGF5bG9hZC5hIC0gcmVzb2x2ZWQucGF5bG9hZC5iLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChzdGF0ZSwgcmVqZWN0ZWQpID0+ICh7c3RhdHVzOiByZWplY3RlZC5zdGF0dXMsIHN1bTogMH0pLFxuICAgICAgICApXG4gICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAoc3RhdGUsIHBlbmRpbmcpID0+ICh7XG4gICAgICAgICAgICBzdGF0dXM6IHBlbmRpbmcuc3RhdHVzLFxuICAgICAgICAgICAgc3VtOiBzdGF0ZS5zdW0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKHN0YXRlLCByZXNvbHZlZCkgPT4gKHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzb2x2ZWQuc3RhdHVzLFxuICAgICAgICAgICAgc3VtOiAwLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChzdGF0ZSwgcmVqZWN0ZWQpID0+ICh7c3RhdHVzOiByZWplY3RlZC5zdGF0dXMsIHN1bTogMH0pLFxuICAgICAgICApXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdG9yZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUoXG4gICAgICBjb21iaW5lUmVkdWNlcnMoeyByZXN1bHQgfSksXG4gICAgICBhcHBseU1pZGRsZXdhcmUobWlkZGxld2FyZSksXG4gICAgKVxuICB9XG5cbiAgZGVzY3JpYmUoJ3BlbmRpbmcgYW5kIHJlc29sdmVkJywgKCkgPT4ge1xuICAgIGl0KCdtYWtlcyBpdCBlYXN5IHRvIGRpc3BhdGNoIGFzeW5jIGFjdGlvbnMgZm9yIHJlZHV4JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSBnZXRTdG9yZSgpXG4gICAgICBhd2FpdCBzdG9yZS5kaXNwYXRjaChhY3Rpb25zLmFkZCgxLCAyKSlcbiAgICAgIGV4cGVjdChzdG9yZS5nZXRTdGF0ZSgpKS50b0VxdWFsKHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgc3RhdHVzOiAncmVzb2x2ZWQnLFxuICAgICAgICAgIHN1bTogMyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICBhd2FpdCBzdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN1YnRyYWN0KDEsIDIpKVxuICAgICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkpLnRvRXF1YWwoe1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBzdGF0dXM6ICdyZXNvbHZlZCcsXG4gICAgICAgICAgc3VtOiAtMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgncmVqZWN0ZWQnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgcmVqZWN0ZWQgYWN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gZ2V0U3RvcmUoKVxuICAgICAgbGV0IGVycm9yITogRXJyb3JcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHN0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVqZWN0KDEsIDIpKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgICB9XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVUcnV0aHkoKVxuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoJ1Rlc3QgcmVqZWN0JylcbiAgICAgIGV4cGVjdChzdG9yZS5nZXRTdGF0ZSgpKS50b0VxdWFsKHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgc3RhdHVzOiAncmVqZWN0ZWQnLFxuICAgICAgICAgIHN1bTogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxufSlcbiJdfQ==