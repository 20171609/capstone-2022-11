"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var ChatActions = __importStar(require("./ChatActions"));
var NicknameActions = __importStar(require("./NicknameActions"));
var NotifyActions = __importStar(require("./NotifyActions"));
var StreamActions = __importStar(require("./StreamActions"));
var constants = __importStar(require("../constants"));
var simple_peer_1 = __importDefault(require("simple-peer"));
var forEach_1 = __importDefault(require("lodash/forEach"));
var debug_1 = __importDefault(require("debug"));
var window_1 = require("../window");
var nickname_1 = require("../nickname");
var debug = debug_1["default"]('peercalls');
var PeerHandler = /** @class */ (function () {
    function PeerHandler(options) {
        var _this = this;
        this.options = options;
        this.handleError = function (err) {
            var _a = _this, dispatch = _a.dispatch, getState = _a.getState, user = _a.user;
            debug('peer: %s, error %s', user.id, err.stack);
            dispatch(NotifyActions.error('A peer connection error occurred'));
            var peer = getState().peers[user.id];
            peer && peer.destroy();
            dispatch(exports.removePeer(user.id));
        };
        this.handleSignal = function (signal) {
            var _a = _this, socket = _a.socket, user = _a.user;
            debug('peer: %s, signal: %o', user.id, signal);
            var payload = { userId: user.id, signal: signal };
            socket.emit('signal', payload);
        };
        this.handleConnect = function () {
            var _a = _this, dispatch = _a.dispatch, user = _a.user, getState = _a.getState;
            debug('peer: %s, connect', user.id);
            dispatch(NotifyActions.warning('Peer connection established'));
            var state = getState();
            var peer = state.peers[user.id];
            var localStream = state.streams[constants.ME];
            localStream && localStream.streams.forEach(function (s) {
                // If the local user pressed join call before this peer has joined the
                // call, now is the time to share local media stream with the peer since
                // we no longer automatically send the stream to the peer.
                s.stream.getTracks().forEach(function (track) {
                    peer.addTrack(track, s.stream);
                });
            });
            var nickname = state.nicknames[constants.ME];
            if (nickname) {
                sendData(peer, {
                    payload: { nickname: nickname },
                    type: 'nickname'
                });
            }
        };
        this.handleTrack = function (track, stream) {
            var _a = _this, user = _a.user, dispatch = _a.dispatch;
            var userId = user.id;
            debug('peer: %s, track: %s', userId, track.id);
            // Listen to mute event to know when a track was removed
            // https://github.com/feross/simple-peer/issues/512
            track.onmute = function () {
                debug('peer: %s, track muted: %s', userId, track.id);
                dispatch(StreamActions.removeTrack({
                    userId: userId,
                    stream: stream,
                    track: track
                }));
            };
            track.onunmute = function () {
                debug('peer: %s, track unmuted: %s', userId, track.id);
                dispatch(StreamActions.addTrack({
                    userId: userId,
                    stream: stream,
                    track: track
                }));
            };
            dispatch(StreamActions.addStream({
                userId: userId,
                stream: stream
            }));
        };
        this.handleData = function (buffer) {
            var _a = _this, dispatch = _a.dispatch, getState = _a.getState, user = _a.user;
            var state = getState();
            var message = JSON.parse(new window.TextDecoder('utf-8').decode(buffer));
            debug('peer: %s, message: %o', user.id, message);
            switch (message.type) {
                case 'file':
                    dispatch(ChatActions.addMessage({
                        userId: user.id,
                        message: message.payload.name,
                        timestamp: new Date().toLocaleString(),
                        image: message.payload.data
                    }));
                    break;
                case 'nickname':
                    dispatch(ChatActions.addMessage({
                        userId: constants.PEERCALLS,
                        message: 'User ' + nickname_1.getNickname(state.nicknames, user.id) +
                            ' is now known as ' + (message.payload.nickname || user.id),
                        timestamp: new Date().toLocaleString(),
                        system: true,
                        image: undefined
                    }));
                    dispatch(NicknameActions.setNickname({
                        userId: user.id,
                        nickname: message.payload.nickname
                    }));
                    break;
                default:
                    dispatch(ChatActions.addMessage({
                        userId: user.id,
                        message: message.payload,
                        timestamp: new Date().toLocaleString(),
                        image: undefined
                    }));
            }
        };
        this.handleClose = function () {
            var _a = _this, dispatch = _a.dispatch, user = _a.user, getState = _a.getState;
            dispatch(NotifyActions.error('Peer connection closed'));
            var state = getState();
            var userStreams = state.streams[user.id];
            userStreams && userStreams.streams.forEach(function (s) {
                dispatch(StreamActions.removeStream(user.id, s.stream));
            });
            dispatch(exports.removePeer(user.id));
        };
        this.socket = options.socket;
        this.user = options.user;
        this.dispatch = options.dispatch;
        this.getState = options.getState;
    }
    return PeerHandler;
}());
/**
 * @param {Object} options
 * @param {Socket} options.socket
 * @param {User} options.user
 * @param {String} options.user.id
 * @param {Boolean} [options.initiator=false]
 * @param {MediaStream} [options.stream]
 */
function createPeer(options) {
    var socket = options.socket, user = options.user, initiator = options.initiator, stream = options.stream;
    return function (dispatch, getState) {
        var userId = user.id;
        debug('create peer: %s, stream:', userId, stream);
        dispatch(NotifyActions.warning('Connecting to peer...'));
        var oldPeer = getState().peers[userId];
        if (oldPeer) {
            dispatch(NotifyActions.info('Cleaning up old connection...'));
            oldPeer.destroy();
            dispatch(exports.removePeer(userId));
        }
        var peer = new simple_peer_1["default"]({
            initiator: userId === initiator,
            config: { iceServers: window_1.iceServers },
            // Allow the peer to receive video, even if it's not sending stream:
            // https://github.com/feross/simple-peer/issues/95
            offerConstraints: {
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            },
            stream: stream
        });
        var handler = new PeerHandler({
            socket: socket,
            user: user,
            dispatch: dispatch,
            getState: getState
        });
        peer.once(constants.PEER_EVENT_ERROR, handler.handleError);
        peer.once(constants.PEER_EVENT_CONNECT, handler.handleConnect);
        peer.once(constants.PEER_EVENT_CLOSE, handler.handleClose);
        peer.on(constants.PEER_EVENT_SIGNAL, handler.handleSignal);
        peer.on(constants.PEER_EVENT_TRACK, handler.handleTrack);
        peer.on(constants.PEER_EVENT_DATA, handler.handleData);
        dispatch(exports.addPeer({ peer: peer, userId: userId }));
    };
}
exports.createPeer = createPeer;
exports.addPeer = function (payload) { return ({
    type: constants.PEER_ADD,
    payload: payload
}); };
exports.removePeer = function (userId) { return ({
    type: constants.PEER_REMOVE,
    payload: { userId: userId }
}); };
function sendData(peer, message) {
    peer.send(JSON.stringify(message));
}
exports.sendMessage = function (message) {
    return function (dispatch, getState) {
        var peers = getState().peers;
        debug('Sending message type: %s to %s peers.', message.type, Object.keys(peers).length);
        switch (message.type) {
            case 'file':
                dispatch(ChatActions.addMessage({
                    userId: constants.ME,
                    message: 'Send file: "' +
                        message.payload.name + '" to all peers',
                    timestamp: new Date().toLocaleString(),
                    image: message.payload.data
                }));
                break;
            case 'nickname':
                dispatch(ChatActions.addMessage({
                    userId: constants.PEERCALLS,
                    message: 'You are now known as: ' + message.payload.nickname,
                    timestamp: new Date().toLocaleString(),
                    system: true,
                    image: undefined
                }));
                dispatch(NicknameActions.setNickname({
                    userId: constants.ME,
                    nickname: message.payload.nickname
                }));
                break;
            default:
                dispatch(ChatActions.addMessage({
                    userId: constants.ME,
                    message: message.payload,
                    timestamp: new Date().toLocaleString(),
                    image: undefined
                }));
        }
        forEach_1["default"](peers, function (peer, userId) {
            sendData(peer, message);
        });
    };
};
exports.sendFile = function (file) {
    return function (dispatch, getState) { return __awaiter(void 0, void 0, void 0, function () {
        var name, size, type, reader, base64File;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    name = file.name, size = file.size, type = file.type;
                    if (!window.FileReader) {
                        dispatch(NotifyActions.error('File API is not supported by your browser'));
                        return [2 /*return*/];
                    }
                    reader = new window.FileReader();
                    return [4 /*yield*/, new Promise(function (resolve) {
                            reader.addEventListener('load', function () {
                                resolve({
                                    name: name,
                                    size: size,
                                    type: type,
                                    data: reader.result
                                });
                            });
                            reader.readAsDataURL(file);
                        })];
                case 1:
                    base64File = _a.sent();
                    exports.sendMessage({ payload: base64File, type: 'file' })(dispatch, getState);
                    return [2 /*return*/];
            }
        });
    }); };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGVlckFjdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpZW50L2FjdGlvbnMvUGVlckFjdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseURBQTRDO0FBQzVDLGlFQUFvRDtBQUNwRCw2REFBZ0Q7QUFDaEQsNkRBQWdEO0FBQ2hELHNEQUF5QztBQUN6Qyw0REFBOEM7QUFDOUMsMkRBQW9DO0FBQ3BDLGdEQUEwQjtBQUMxQixvQ0FBc0M7QUFHdEMsd0NBQXlDO0FBRXpDLElBQU0sS0FBSyxHQUFHLGtCQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7QUFhakM7SUFNRSxxQkFBc0IsT0FBMkI7UUFBakQsaUJBS0M7UUFMcUIsWUFBTyxHQUFQLE9BQU8sQ0FBb0I7UUFNakQsZ0JBQVcsR0FBRyxVQUFDLEdBQVU7WUFDakIsSUFBQSxVQUFtQyxFQUFqQyxzQkFBUSxFQUFFLHNCQUFRLEVBQUUsY0FBYSxDQUFBO1lBQ3pDLEtBQUssQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUMvQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUE7WUFDakUsSUFBTSxJQUFJLEdBQUcsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQTtZQUN0QyxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFBO1lBQ3RCLFFBQVEsQ0FBQyxrQkFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQy9CLENBQUMsQ0FBQTtRQUNELGlCQUFZLEdBQUcsVUFBQyxNQUFrQjtZQUMxQixJQUFBLFVBQXVCLEVBQXJCLGtCQUFNLEVBQUUsY0FBYSxDQUFBO1lBQzdCLEtBQUss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Z0I7aUNBQzlCLENBQUMsQ0FBQTs0QkFDSixDQUFDLENBQUMsQ0FBQTs0QkFDRixNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFBO3dCQUM1QixDQUFDLENBQUMsRUFBQTs7b0JBVkksVUFBVSxHQUFHLFNBVWpCO29CQUVGLG1CQUFXLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQTs7OztTQUN2RTtBQXBCRCxDQW9CQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ2hhdEFjdGlvbnMgZnJvbSAnLi9DaGF0QWN0aW9ucydcbmltcG9ydCAqIGFzIE5pY2tuYW1lQWN0aW9ucyBmcm9tICcuL05pY2tuYW1lQWN0aW9ucydcbmltcG9ydCAqIGFzIE5vdGlmeUFjdGlvbnMgZnJvbSAnLi9Ob3RpZnlBY3Rpb25zJ1xuaW1wb3J0ICogYXMgU3RyZWFtQWN0aW9ucyBmcm9tICcuL1N0cmVhbUFjdGlvbnMnXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzJ1xuaW1wb3J0IFBlZXIsIHsgU2lnbmFsRGF0YSB9IGZyb20gJ3NpbXBsZS1wZWVyJ1xuaW1wb3J0IGZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnXG5pbXBvcnQgX2RlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgaWNlU2VydmVycyB9IGZyb20gJy4uL3dpbmRvdydcbmltcG9ydCB7IERpc3BhdGNoLCBHZXRTdGF0ZSB9IGZyb20gJy4uL3N0b3JlJ1xuaW1wb3J0IHsgQ2xpZW50U29ja2V0IH0gZnJvbSAnLi4vc29ja2V0J1xuaW1wb3J0IHsgZ2V0Tmlja25hbWUgfSBmcm9tICcuLi9uaWNrbmFtZSdcblxuY29uc3QgZGVidWcgPSBfZGVidWcoJ3BlZXJjYWxscycpXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVlcnMge1xuICBbaWQ6IHN0cmluZ106IFBlZXIuSW5zdGFuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZWVySGFuZGxlck9wdGlvbnMge1xuICBzb2NrZXQ6IENsaWVudFNvY2tldFxuICB1c2VyOiB7IGlkOiBzdHJpbmcgfVxuICBkaXNwYXRjaDogRGlzcGF0Y2hcbiAgZ2V0U3RhdGU6IEdldFN0YXRlXG59XG5cbmNsYXNzIFBlZXJIYW5kbGVyIHtcbiAgc29ja2V0OiBDbGllbnRTb2NrZXRcbiAgdXNlcjogeyBpZDogc3RyaW5nIH1cbiAgZGlzcGF0Y2g6IERpc3BhdGNoXG4gIGdldFN0YXRlOiBHZXRTdGF0ZVxuXG4gIGNvbnN0cnVjdG9yIChyZWFkb25seSBvcHRpb25zOiBQZWVySGFuZGxlck9wdGlvbnMpIHtcbiAgICB0aGlzLnNvY2tldCA9IG9wdGlvbnMuc29ja2V0XG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyXG4gICAgdGhpcy5kaXNwYXRjaCA9IG9wdGlvbnMuZGlzcGF0Y2hcbiAgICB0aGlzLmdldFN0YXRlID0gb3B0aW9ucy5nZXRTdGF0ZVxuICB9XG4gIGhhbmRsZUVycm9yID0gKGVycjogRXJyb3IpID0+IHtcbiAgICBjb25zdCB7IGRpc3BhdGNoLCBnZXRTdGF0ZSwgdXNlciB9ID0gdGhpc1xuICAgIGRlYnVnKCdwZWVyOiAlcywgZXJyb3IgJXMnLCB1c2VyLmlkLCBlcnIuc3RhY2spXG4gICAgZGlzcGF0Y2goTm90aWZ5QWN0aW9ucy5lcnJvcignQSBwZWVyIGNvbm5lY3Rpb24gZXJyb3Igb2NjdXJyZWQnKSlcbiAgICBjb25zdCBwZWVyID0gZ2V0U3RhdGUoKS5wZWVyc1t1c2VyLmlkXVxuICAgIHBlZXIgJiYgcGVlci5kZXN0cm95KClcbiAgICBkaXNwYXRjaChyZW1vdmVQZWVyKHVzZXIuaWQpKVxuICB9XG4gIGhhbmRsZVNpZ25hbCA9IChzaWduYWw6IFNpZ25hbERhdGEpID0+IHtcbiAgICBjb25zdCB7IHNvY2tldCwgdXNlciB9ID0gdGhpc1xuICAgIGRlYnVnKCdwZWVyOiAlcywgc2lnbmFsOiAlbycsIHVzZXIuaWQsIHNpZ25hbClcblxuICAgIGNvbnN0IHBheWxvYWQgPSB7IHVzZXJJZDogdXNlci5pZCwgc2lnbmFsIH1cbiAgICBzb2NrZXQuZW1pdCgnc2lnbmFsJywgcGF5bG9hZClcbiAgfVxuICBoYW5kbGVDb25uZWN0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGlzcGF0Y2gsIHVzZXIsIGdldFN0YXRlIH0gPSB0aGlzXG4gICAgZGVidWcoJ3BlZXI6ICVzLCBjb25uZWN0JywgdXNlci5pZClcbiAgICBkaXNwYXRjaChOb3RpZnlBY3Rpb25zLndhcm5pbmcoJ1BlZXIgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcpKVxuXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpXG4gICAgY29uc3QgcGVlciA9IHN0YXRlLnBlZXJzW3VzZXIuaWRdXG4gICAgY29uc3QgbG9jYWxTdHJlYW0gPSBzdGF0ZS5zdHJlYW1zW2NvbnN0YW50cy5NRV1cbiAgICBsb2NhbFN0cmVhbSAmJiBsb2NhbFN0cmVhbS5zdHJlYW1zLmZvckVhY2gocyA9PiB7XG4gICAgICAvLyBJZiB0aGUgbG9jYWwgdXNlciBwcmVzc2VkIGpvaW4gY2FsbCBiZWZvcmUgdGhpcyBwZWVyIGhhcyBqb2luZWQgdGhlXG4gICAgICAvLyBjYWxsLCBub3cgaXMgdGhlIHRpbWUgdG8gc2hhcmUgbG9jYWwgbWVkaWEgc3RyZWFtIHdpdGggdGhlIHBlZXIgc2luY2VcbiAgICAgIC8vIHdlIG5vIGxvbmdlciBhdXRvbWF0aWNhbGx5IHNlbmQgdGhlIHN0cmVhbSB0byB0aGUgcGVlci5cbiAgICAgIHMuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICBwZWVyLmFkZFRyYWNrKHRyYWNrLCBzLnN0cmVhbSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICBjb25zdCBuaWNrbmFtZSA9IHN0YXRlLm5pY2tuYW1lc1tjb25zdGFudHMuTUVdXG4gICAgaWYgKG5pY2tuYW1lKSB7XG4gICAgICBzZW5kRGF0YShwZWVyLCB7XG4gICAgICAgIHBheWxvYWQ6IHtuaWNrbmFtZX0sXG4gICAgICAgIHR5cGU6ICduaWNrbmFtZScsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBoYW5kbGVUcmFjayA9ICh0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlciwgZGlzcGF0Y2ggfSA9IHRoaXNcbiAgICBjb25zdCB1c2VySWQgPSB1c2VyLmlkXG4gICAgZGVidWcoJ3BlZXI6ICVzLCB0cmFjazogJXMnLCB1c2VySWQsIHRyYWNrLmlkKVxuICAgIC8vIExpc3RlbiB0byBtdXRlIGV2ZW50IHRvIGtub3cgd2hlbiBhIHRyYWNrIHdhcyByZW1vdmVkXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlci9pc3N1ZXMvNTEyXG4gICAgdHJhY2sub25tdXRlID0gKCkgPT4ge1xuICAgICAgZGVidWcoJ3BlZXI6ICVzLCB0cmFjayBtdXRlZDogJXMnLCB1c2VySWQsIHRyYWNrLmlkKVxuICAgICAgZGlzcGF0Y2goU3RyZWFtQWN0aW9ucy5yZW1vdmVUcmFjayh7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICB0cmFjayxcbiAgICAgIH0pKVxuICAgIH1cbiAgICB0cmFjay5vbnVubXV0ZSA9ICgpID0+IHtcbiAgICAgIGRlYnVnKCdwZWVyOiAlcywgdHJhY2sgdW5tdXRlZDogJXMnLCB1c2VySWQsIHRyYWNrLmlkKVxuICAgICAgZGlzcGF0Y2goU3RyZWFtQWN0aW9ucy5hZGRUcmFjayh7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICB0cmFjayxcbiAgICAgIH0pKVxuICAgIH1cbiAgICBkaXNwYXRjaChTdHJlYW1BY3Rpb25zLmFkZFN0cmVhbSh7XG4gICAgICB1c2VySWQsXG4gICAgICBzdHJlYW0sXG4gICAgfSkpXG4gIH1cbiAgaGFuZGxlRGF0YSA9IChidWZmZXI6IEFycmF5QnVmZmVyKSA9PiB7XG4gICAgY29uc3QgeyBkaXNwYXRjaCwgZ2V0U3RhdGUsIHVzZXIgfSA9IHRoaXNcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKClcbiAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShuZXcgd2luZG93LlRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZShidWZmZXIpKVxuICAgIGRlYnVnKCdwZWVyOiAlcywgbWVzc2FnZTogJW8nLCB1c2VyLmlkLCBtZXNzYWdlKVxuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgZGlzcGF0Y2goQ2hhdEFjdGlvbnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UucGF5bG9hZC5uYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgIGltYWdlOiBtZXNzYWdlLnBheWxvYWQuZGF0YSxcbiAgICAgICAgfSkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICduaWNrbmFtZSc6XG4gICAgICAgIGRpc3BhdGNoKENoYXRBY3Rpb25zLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgIHVzZXJJZDogY29uc3RhbnRzLlBFRVJDQUxMUyxcbiAgICAgICAgICBtZXNzYWdlOiAnVXNlciAnICsgZ2V0Tmlja25hbWUoc3RhdGUubmlja25hbWVzLCB1c2VyLmlkKSArXG4gICAgICAgICAgICAnIGlzIG5vdyBrbm93biBhcyAnICsgKG1lc3NhZ2UucGF5bG9hZC5uaWNrbmFtZSB8fCB1c2VyLmlkKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICBzeXN0ZW06IHRydWUsXG4gICAgICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkpXG4gICAgICAgIGRpc3BhdGNoKE5pY2tuYW1lQWN0aW9ucy5zZXROaWNrbmFtZSh7XG4gICAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICAgIG5pY2tuYW1lOiBtZXNzYWdlLnBheWxvYWQubmlja25hbWUsXG4gICAgICAgIH0pKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGlzcGF0Y2goQ2hhdEFjdGlvbnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICBpbWFnZTogdW5kZWZpbmVkLFxuICAgICAgICB9KSlcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkaXNwYXRjaCwgdXNlciwgZ2V0U3RhdGUgfSA9IHRoaXNcbiAgICBkaXNwYXRjaChOb3RpZnlBY3Rpb25zLmVycm9yKCdQZWVyIGNvbm5lY3Rpb24gY2xvc2VkJykpXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpXG4gICAgY29uc3QgdXNlclN0cmVhbXMgPSBzdGF0ZS5zdHJlYW1zW3VzZXIuaWRdXG4gICAgdXNlclN0cmVhbXMgJiYgdXNlclN0cmVhbXMuc3RyZWFtcy5mb3JFYWNoKHMgPT4ge1xuICAgICAgZGlzcGF0Y2goU3RyZWFtQWN0aW9ucy5yZW1vdmVTdHJlYW0odXNlci5pZCwgcy5zdHJlYW0pKVxuICAgIH0pXG4gICAgZGlzcGF0Y2gocmVtb3ZlUGVlcih1c2VyLmlkKSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVBlZXJPcHRpb25zIHtcbiAgc29ja2V0OiBDbGllbnRTb2NrZXRcbiAgdXNlcjogeyBpZDogc3RyaW5nIH1cbiAgaW5pdGlhdG9yOiBzdHJpbmdcbiAgc3RyZWFtPzogTWVkaWFTdHJlYW1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTb2NrZXR9IG9wdGlvbnMuc29ja2V0XG4gKiBAcGFyYW0ge1VzZXJ9IG9wdGlvbnMudXNlclxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXNlci5pZFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbml0aWF0b3I9ZmFsc2VdXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbb3B0aW9ucy5zdHJlYW1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQZWVyIChvcHRpb25zOiBDcmVhdGVQZWVyT3B0aW9ucykge1xuICBjb25zdCB7IHNvY2tldCwgdXNlciwgaW5pdGlhdG9yLCBzdHJlYW0gfSA9IG9wdGlvbnNcblxuICByZXR1cm4gKGRpc3BhdGNoOiBEaXNwYXRjaCwgZ2V0U3RhdGU6IEdldFN0YXRlKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gdXNlci5pZFxuICAgIGRlYnVnKCdjcmVhdGUgcGVlcjogJXMsIHN0cmVhbTonLCB1c2VySWQsIHN0cmVhbSlcbiAgICBkaXNwYXRjaChOb3RpZnlBY3Rpb25zLndhcm5pbmcoJ0Nvbm5lY3RpbmcgdG8gcGVlci4uLicpKVxuXG4gICAgY29uc3Qgb2xkUGVlciA9IGdldFN0YXRlKCkucGVlcnNbdXNlcklkXVxuICAgIGlmIChvbGRQZWVyKSB7XG4gICAgICBkaXNwYXRjaChOb3RpZnlBY3Rpb25zLmluZm8oJ0NsZWFuaW5nIHVwIG9sZCBjb25uZWN0aW9uLi4uJykpXG4gICAgICBvbGRQZWVyLmRlc3Ryb3koKVxuICAgICAgZGlzcGF0Y2gocmVtb3ZlUGVlcih1c2VySWQpKVxuICAgIH1cblxuICAgIGNvbnN0IHBlZXIgPSBuZXcgUGVlcih7XG4gICAgICBpbml0aWF0b3I6IHVzZXJJZCA9PT0gaW5pdGlhdG9yLFxuICAgICAgY29uZmlnOiB7IGljZVNlcnZlcnMgfSxcbiAgICAgIC8vIEFsbG93IHRoZSBwZWVyIHRvIHJlY2VpdmUgdmlkZW8sIGV2ZW4gaWYgaXQncyBub3Qgc2VuZGluZyBzdHJlYW06XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy85NVxuICAgICAgb2ZmZXJDb25zdHJhaW50czoge1xuICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHN0cmVhbSxcbiAgICB9KVxuXG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBQZWVySGFuZGxlcih7XG4gICAgICBzb2NrZXQsXG4gICAgICB1c2VyLFxuICAgICAgZGlzcGF0Y2gsXG4gICAgICBnZXRTdGF0ZSxcbiAgICB9KVxuXG4gICAgcGVlci5vbmNlKGNvbnN0YW50cy5QRUVSX0VWRU5UX0VSUk9SLCBoYW5kbGVyLmhhbmRsZUVycm9yKVxuICAgIHBlZXIub25jZShjb25zdGFudHMuUEVFUl9FVkVOVF9DT05ORUNULCBoYW5kbGVyLmhhbmRsZUNvbm5lY3QpXG4gICAgcGVlci5vbmNlKGNvbnN0YW50cy5QRUVSX0VWRU5UX0NMT1NFLCBoYW5kbGVyLmhhbmRsZUNsb3NlKVxuICAgIHBlZXIub24oY29uc3RhbnRzLlBFRVJfRVZFTlRfU0lHTkFMLCBoYW5kbGVyLmhhbmRsZVNpZ25hbClcbiAgICBwZWVyLm9uKGNvbnN0YW50cy5QRUVSX0VWRU5UX1RSQUNLLCBoYW5kbGVyLmhhbmRsZVRyYWNrKVxuICAgIHBlZXIub24oY29uc3RhbnRzLlBFRVJfRVZFTlRfREFUQSwgaGFuZGxlci5oYW5kbGVEYXRhKVxuXG4gICAgZGlzcGF0Y2goYWRkUGVlcih7IHBlZXIsIHVzZXJJZCB9KSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZFBlZXJQYXJhbXMge1xuICBwZWVyOiBQZWVyLkluc3RhbmNlXG4gIHVzZXJJZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkUGVlckFjdGlvbiB7XG4gIHR5cGU6ICdQRUVSX0FERCdcbiAgcGF5bG9hZDogQWRkUGVlclBhcmFtc1xufVxuXG5leHBvcnQgY29uc3QgYWRkUGVlciA9IChwYXlsb2FkOiBBZGRQZWVyUGFyYW1zKTogQWRkUGVlckFjdGlvbiA9PiAoe1xuICB0eXBlOiBjb25zdGFudHMuUEVFUl9BREQsXG4gIHBheWxvYWQsXG59KVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZVBlZXJBY3Rpb24ge1xuICB0eXBlOiAnUEVFUl9SRU1PVkUnXG4gIHBheWxvYWQ6IHsgdXNlcklkOiBzdHJpbmcgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlUGVlciA9ICh1c2VySWQ6IHN0cmluZyk6IFJlbW92ZVBlZXJBY3Rpb24gPT4gKHtcbiAgdHlwZTogY29uc3RhbnRzLlBFRVJfUkVNT1ZFLFxuICBwYXlsb2FkOiB7IHVzZXJJZCB9LFxufSlcblxuZXhwb3J0IHR5cGUgUGVlckFjdGlvbiA9XG4gIEFkZFBlZXJBY3Rpb24gfFxuICBSZW1vdmVQZWVyQWN0aW9uXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dE1lc3NhZ2Uge1xuICB0eXBlOiAndGV4dCdcbiAgcGF5bG9hZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZTY0RmlsZSB7XG4gIG5hbWU6IHN0cmluZ1xuICBzaXplOiBudW1iZXJcbiAgdHlwZTogc3RyaW5nXG4gIGRhdGE6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVNZXNzYWdlIHtcbiAgdHlwZTogJ2ZpbGUnXG4gIHBheWxvYWQ6IEJhc2U2NEZpbGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOaWNrbmFtZU1lc3NhZ2Uge1xuICB0eXBlOiAnbmlja25hbWUnXG4gIHBheWxvYWQ6IHtcbiAgICBuaWNrbmFtZTogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTWVzc2FnZSA9IFRleHRNZXNzYWdlIHwgRmlsZU1lc3NhZ2UgfCBOaWNrbmFtZU1lc3NhZ2VcblxuZnVuY3Rpb24gc2VuZERhdGEocGVlcjogUGVlci5JbnN0YW5jZSwgbWVzc2FnZTogTWVzc2FnZSkge1xuICBwZWVyLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpXG59XG5cbmV4cG9ydCBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlOiBNZXNzYWdlKSA9PlxuKGRpc3BhdGNoOiBEaXNwYXRjaCwgZ2V0U3RhdGU6IEdldFN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgcGVlcnMgfSA9IGdldFN0YXRlKClcbiAgZGVidWcoJ1NlbmRpbmcgbWVzc2FnZSB0eXBlOiAlcyB0byAlcyBwZWVycy4nLFxuICAgIG1lc3NhZ2UudHlwZSwgT2JqZWN0LmtleXMocGVlcnMpLmxlbmd0aClcbiAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIGRpc3BhdGNoKENoYXRBY3Rpb25zLmFkZE1lc3NhZ2Uoe1xuICAgICAgICB1c2VySWQ6IGNvbnN0YW50cy5NRSxcbiAgICAgICAgbWVzc2FnZTogJ1NlbmQgZmlsZTogXCInICtcbiAgICAgICAgICBtZXNzYWdlLnBheWxvYWQubmFtZSArICdcIiB0byBhbGwgcGVlcnMnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgaW1hZ2U6IG1lc3NhZ2UucGF5bG9hZC5kYXRhLFxuICAgICAgfSkpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ25pY2tuYW1lJzpcbiAgICAgIGRpc3BhdGNoKENoYXRBY3Rpb25zLmFkZE1lc3NhZ2Uoe1xuICAgICAgICB1c2VySWQ6IGNvbnN0YW50cy5QRUVSQ0FMTFMsXG4gICAgICAgIG1lc3NhZ2U6ICdZb3UgYXJlIG5vdyBrbm93biBhczogJyArIG1lc3NhZ2UucGF5bG9hZC5uaWNrbmFtZSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgIHN5c3RlbTogdHJ1ZSxcbiAgICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIH0pKVxuICAgICAgZGlzcGF0Y2goTmlja25hbWVBY3Rpb25zLnNldE5pY2tuYW1lKHtcbiAgICAgICAgdXNlcklkOiBjb25zdGFudHMuTUUsXG4gICAgICAgIG5pY2tuYW1lOiBtZXNzYWdlLnBheWxvYWQubmlja25hbWUsXG4gICAgICB9KSlcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGRpc3BhdGNoKENoYXRBY3Rpb25zLmFkZE1lc3NhZ2Uoe1xuICAgICAgICB1c2VySWQ6IGNvbnN0YW50cy5NRSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5wYXlsb2FkLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIH0pKVxuICB9XG4gIGZvckVhY2gocGVlcnMsIChwZWVyLCB1c2VySWQpID0+IHtcbiAgICBzZW5kRGF0YShwZWVyLCBtZXNzYWdlKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgc2VuZEZpbGUgPSAoZmlsZTogRmlsZSkgPT5cbmFzeW5jIChkaXNwYXRjaDogRGlzcGF0Y2gsIGdldFN0YXRlOiBHZXRTdGF0ZSkgPT4ge1xuICBjb25zdCB7IG5hbWUsIHNpemUsIHR5cGUgfSA9IGZpbGVcbiAgaWYgKCF3aW5kb3cuRmlsZVJlYWRlcikge1xuICAgIGRpc3BhdGNoKE5vdGlmeUFjdGlvbnMuZXJyb3IoJ0ZpbGUgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyJykpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKClcbiAgY29uc3QgYmFzZTY0RmlsZSA9IGF3YWl0IG5ldyBQcm9taXNlPEJhc2U2NEZpbGU+KHJlc29sdmUgPT4ge1xuICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGE6IHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nLFxuICAgICAgfSlcbiAgICB9KVxuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gIH0pXG5cbiAgc2VuZE1lc3NhZ2UoeyBwYXlsb2FkOiBiYXNlNjRGaWxlLCB0eXBlOiAnZmlsZScgfSkoZGlzcGF0Y2gsIGdldFN0YXRlKVxufVxuIl19